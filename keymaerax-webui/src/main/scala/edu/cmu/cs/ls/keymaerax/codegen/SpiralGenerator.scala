/**
* Copyright (c) Carnegie Mellon University. CONFIDENTIAL
* See LICENSE.txt for the conditions of this license.
*/
package edu.cmu.cs.ls.keymaerax.codegen

import java.io.{FileWriter, File}

import edu.cmu.cs.ls.keymaerax.core._
import edu.cmu.cs.ls.keymaerax.tools.{JLinkMathematicaLink, MathematicaToKeYmaera}

/**
 * Created by ran on 7/3/15.
 * @author Ran Ji
 */
class SpiralMonitorGenerator extends CodeGenerator {
  def apply(kExpr: Expression): String = generateSpiralMonitor(kExpr)

  def generateSpiralMonitorFile(kExpr: Expression, fileName: String) : File = {
    val gFileTempDir = System.getProperty("user.home") + File.separator + ".keymaerax"
    val gFile = new File(gFileTempDir, fileName)
    val writer = new FileWriter(gFile)
    writer.write(generateSpiralMonitor(kExpr))
    writer.flush()
    writer.close()
    gFile
  }

  private def generateSpiralMonitor(kExpr: Expression) : String = {
    info + libs + varDec + monDec + compileToSpiral(kExpr)
  }

  private val info = "# *************************\n" +
    "# Generated by KeYmaera X\n" +
    "# *************************\n"

  private val libs = "# imports\n" +
    "Import(spl, formgen, code, rewrite, transforms, search, compiler, sigma, platforms, platforms.sse, paradigms.common, paradigms.vector, paradigms.cache, libgen, backend);\n" +
    "ImportAll(packages.hacms);\n" +
    "ImportAll(paradigms.vector);\n\n"

  private val vectorName = "d"

  private val varDec = "# declare constant table\n" +
    vectorName + " := var(\"" + vectorName+ "\", TPtr(T_Real(64)));\n"

  private val monDec = "# monitor\n" +
    "t := \n"

  private def compileToSpiral(e: Expression) = e match {
    case t : Term => compilePolynimialTerm(t)
    case f : Formula => compileFormula(f)
    case _ => ???
  }

  def compilePolynimialTerm(t: Term) : String = {
    var coeffs: Array[Expression] = polynomialCoefficients(t)
    if(coeffs.length == 0 || coeffs == null) {
      compileTerm(t)
    } else //      def infoConst = "# constants\n" + vectorName + " := var(\"" + vectorName+ "\", TPtr(T_Real(64)));\n"
      compilePolynomial(coeffs)

  }

  def compileTerm(t: Term) : String = {
    require(t.sort == Real || t.sort == Unit, "can only deal with reals not with sort " + t.sort)
    t match {
      case Neg(c) => "neg(" + compileTerm(c) + ")"
      case Plus(l, r) => "add(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Minus(l, r) => "sub(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Times(l, r) => "mul(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Divide(l, r) => "div(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Power(l, r) => "pow(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      // atomic terms
      case Number(n) =>
        assert(n.isValidDouble || n.isValidLong, throw new CodeGenerationException("Term " + t.prettyString() + " contains illegal numbers"))
        "TReal.value(" + n.underlying().toString + ")"
      case t: Variable =>
        if(t.index.isEmpty) t.name
        else t.name + "_" + t.index.get
      case FuncOf(fn, child) =>
        if(child.equals(Nothing)) fn.name
        else fn.name match {
          case "Abs" => "abs(" + compileTerm(child) + ")"
          case "DChebyshev" => "TDistance(TInfinityNorm(" + "2" + "))"  //hack for InfinityNorm of degree 2
          case _ => fn.name + "(" + compileTerm(child) + ")"
        }
      // otherwise exception
      case _ => throw new CodeGenerationException("Conversion of term " + t.prettyString() + " is not defined")
    }
  }

  def compileFormula(f: Formula) : String = {
    f match {
      // sub terms are formulas
      case Not(ff) => "logic_neg(" + compileFormula(ff) + ")"
      case And(l, r) => "logic_and(" + compileFormula(l) + ", " + compileFormula(r) + ")"
      case Or(l, r) => "logic_or(" + compileFormula(l) + ", " + compileFormula(r) + ")"
      case Imply(l, r) => "logic_impl(" + compileFormula(l) + ", " + compileFormula(r) + ")"
      case Equiv(l, r) => "logic_equiv(" + compileFormula(l) + ", " + compileFormula(r) + ")"

      // sub terms are arithmetic terms
      case Equal(l, r) => "TEqual(" + compilePolynimialTerm(l) + ", " + compilePolynimialTerm(r) + ")"
      case NotEqual(l, r) => "TNotEqual(" + compilePolynimialTerm(l) + ", " + compilePolynimialTerm(r) + ")"
      case Greater(l,r) => "TLess(" + compilePolynimialTerm(r) + ", " + compilePolynimialTerm(l) + ")"
      case GreaterEqual(l,r) => "TLessEqual(" + compilePolynimialTerm(r) + ", " + compilePolynimialTerm(l) + ")"
      case Less(l,r) => "TLess(" + compilePolynimialTerm(l) + ", " + compilePolynimialTerm(r) + ")"
      case LessEqual(l,r) => "TLessEqual(" + compilePolynimialTerm(l) + ", " + compilePolynimialTerm(r) + ")"
      //      case True => "1"
      //      case False => "0"
      case Box(_, _) | Diamond(_, _) => throw new CodeGenerationException("Conversion of Box or Diamond modality is not allowed")
      case _ => throw new CodeGenerationException("Conversion of formula " + f.prettyString() + " is not defined")
    }
  }

  def polynomialCoefficients(t: Term) : Array[Expression] = {
    val link : JLinkMathematicaLink= new JLinkMathematicaLink()
//    link.init("/usr/local/Wolfram/Mathematica/10.0/Executables/MathKernel", None)
    link.init("/Applications/Mathematica.app/Contents/MacOS/MathKernel", None)
    link.ml.evaluate("CoefficientList["+ t.prettyString() + "," + "v" +"]") // a hack for variable, should read from commmand line
    link.ml.waitForAnswer()
    val resCoeffList = link.ml.getExpr
    val resCoeffListLength = resCoeffList.length()
    var coeffVector: Array[Expression] = new Array[Expression](resCoeffListLength)
    for(i <- 0 until resCoeffListLength) {
      coeffVector(i) = MathematicaToKeYmaera.fromMathematica(resCoeffList.args().apply(resCoeffListLength-1-i))
    }
    coeffVector
  }

  def computePolyCoeffDouble(polyCoeff: Array[Expression]) : Array[Double] = {
    var res : Array[Double] = new Array[Double](polyCoeff.length)
    for(i <- 0 until polyCoeff.length) {
      polyCoeff(i) match {
        case Number(n) => res(i) = n.underlying().doubleValue()
        case _ => throw new CodeGenerationException("Conversion of expression to double is not defined")
      }
    }
    res
  }

  def compilePolynomial(t: Array[Expression]) : String = {
    val sprialHeader = new SpiralHeaderGenerator
    println("Spiral Header is: " + sprialHeader.generateSpiralHeader(computePolyCoeffDouble(t)))
    sprialHeader.generateSpiralHeaderFile(computePolyCoeffDouble(t), "file.h")
    val degree = t.length - 1
    "TEvalPolynomial(" + degree + "," + vectorName + ")"
  }
}

class SpiralHeaderGenerator {

  def generateSpiralHeaderFile(coeffVec: Array[Double], fileName: String) : File = {
    val hFileTempDir = System.getProperty("user.home") + File.separator + ".keymaerax"
    val hFile = new File(hFileTempDir, fileName)
    val writer = new FileWriter(hFile)
    writer.write(generateSpiralHeader(coeffVec))
    writer.flush()
    writer.close()
    hFile
  }

  def generateSpiralHeader(coeffVec: Array[Double]) : String = {
    info + ifnDef + define + coeffsHex(coeffVec) + endIf
  }

  private val info = "/**************************\n" +
    "* Generated by KeYmaera X\n" +
    "**************************/\n\n"

  private val funcName = "filename".toUpperCase()
  private val ifnDef = "#ifndef _"+ funcName + "_H_\n"
  private val define = "#define _" + funcName + "_H_\n"
  private val endIf = "#endif"
  private val vectorName = "d"

  def coeffsHex(coeffVec: Array[Double]) : String = "\n__int64 " + vectorName + "[] = {\n" + translateToCoeffsHex(coeffVec) + "\n};\n"

  private def translateToCoeffsHex(coeffVec: Array[Double]) : String = {
    var coeffsHex = ""
    for(i <- 0 until coeffVec.length) {
      coeffsHex += "  " + translateToHex(coeffVec(i))
      if(i != coeffVec.length-1) coeffsHex += ",\n"
    }
    coeffsHex
  }

  def translateToHex(value: Double) = "0x" + java.lang.Long.toHexString(java.lang.Double.doubleToRawLongBits(value))
}




