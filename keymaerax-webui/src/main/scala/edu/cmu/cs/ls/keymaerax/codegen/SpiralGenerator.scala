/**
 * Copyright (c) Carnegie Mellon University. CONFIDENTIAL
 * See LICENSE.txt for the conditions of this license.
 */
package edu.cmu.cs.ls.keymaerax.codegen

import java.io.{FileWriter, File}

import com.wolfram.jlink.Expr
import edu.cmu.cs.ls.keymaerax.core._
import edu.cmu.cs.ls.keymaerax.launcher.DefaultConfiguration
import edu.cmu.cs.ls.keymaerax.tools.{KeYmaeraToMathematica, JLinkMathematicaLink, MathematicaToKeYmaera}

import scala.collection.immutable.Map

/**
 * Created by ran on 7/3/15.
 * @author Ran Ji
 */
class Hcol {
  private var constTbl : String = ""
  private var monitor : String  = ""
  private var coefficientHex : String = ""

  def getConstTbl = this.constTbl
  def setConstTbl(ct : String) = this.constTbl = ct
  def getMonitor = this.monitor
  def setMonitor(mnt : String) = this.monitor = mnt
  def getCoefficientHex = this.coefficientHex
  def setCoefficientHex(ceh : String) = this.coefficientHex = ceh
}

class SpiralGenerator extends CodeGenerator {
  def apply(kExpr: Expression): String = apply(kExpr, "FILENAME")
  def apply(kExpr: Expression, fileName: String): String = generateSpiralMonitor(kExpr, fileName)._1

  private val hcol = new Hcol

  // marthematica setting
  private val mathematicaConfig: Map[String, String] = DefaultConfiguration.defaultMathematicaConfig
  private val link : JLinkMathematicaLink= new JLinkMathematicaLink()
  link.init(mathematicaConfig.apply(mathematicaConfig.keys.head), None)

  // name counter used for generating new vector names
  private var vecNameCounter : Int = 0

  // printigs for monitor generation
  private def infoG(fileName: String) =
    "# *************************\n" +
    "# " + fileName + ".g\n" +
    "# \n" +
    "# Generated by KeYmaera X\n" +
    "# *************************\n"

  private val libs = "# imports\n" +
    "Import(spl, formgen, code, rewrite, transforms, search, compiler, sigma, platforms, platforms.sse, paradigms.common, paradigms.vector, paradigms.cache, libgen, backend);\n" +
    "ImportAll(packages.hacms);\n" +
    "ImportAll(paradigms.vector);\n\n"

  private val monDec = "# monitor\n" +
    "t := \n"

  // printings for coefficientHex generation

  private def infoH(fileName: String) =
    "/**************************\n" +
    "* " + fileName + ".h\n" +
    "* \n" +
    "* Generated by KeYmaera X\n" +
    "**************************/\n\n"

  private def ifnDef(fileName: String) = "#ifndef _"+ fileName.toUpperCase() + "_H_\n"
  private def define(fileName: String) = "#define _" + fileName.toUpperCase() + "_H_\n"
  private val endIf = "#endif"


  def generateSpiralMonitorFile(kExpr: Expression, fileName: String) : File = {
    val gFileTempDir = System.getProperty("user.home") + File.separator + ".keymaerax"
    val gFile = new File(gFileTempDir, fileName)
    val writer = new FileWriter(gFile)
    writer.write(generateSpiralMonitor(kExpr, fileName)._1)
    writer.flush()
    writer.close()
    gFile
  }

  def generateSpiralHeaderFile(kExpr: Expression, fileName: String) : File = {
    val hFileTempDir = System.getProperty("user.home") + File.separator + ".keymaerax"
    val hFile = new File(hFileTempDir, fileName)
    val writer = new FileWriter(hFile)
    writer.write(generateSpiralMonitor(kExpr, fileName)._2)
    writer.flush()
    writer.close()
    hFile
  }

  def generateSpiralMonitor(kExpr: Expression, fileName: String) : (String, String) = {
    val spiralMonitor = compileToSpiral(kExpr)
    hcol.setMonitor(spiralMonitor)
    val gCode = infoG(fileName) + libs + "# declare constant table\n" + hcol.getConstTbl + monDec + hcol.getMonitor + "\n;\n"
    val hCode = infoH(fileName) + ifnDef(fileName) + define(fileName) + hcol.getCoefficientHex + endIf
    (gCode, hCode)
  }

  private def compileToSpiral(e: Expression) = e match {
    case t : Term => compilePolynomialTerm(t)
    case f : Formula => compileFormula(f)
    case _ => ???
  }

  private def compileTerm(t: Term) : String = {
    require(t.sort == Real || t.sort == Unit, "can only deal with reals not with sort " + t.sort)
    t match {
      case Neg(c) => "neg(" + compileTerm(c) + ")"
      case Plus(l, r) => "add(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Minus(l, r) => "sub(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Times(l, r) => "mul(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Divide(l, r) => "div(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Power(l, r) => "pow(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      // atomic terms
      case Number(n) =>
        assert(n.isValidDouble || n.isValidLong, throw new CodeGenerationException("Term " + t.prettyString + " contains illegal numbers"))
        "TReal.value(" + n.underlying().toString + ")"
      case t: Variable =>
        if(t.index.isEmpty) t.name
        else t.name + "_" + t.index.get
      case FuncOf(fn, child) =>
        if(child.equals(Nothing)) fn.name
        else fn.name match {
          case "Abs" => "abs(" + compileTerm(child) + ")"
          case "DChebyshev" => "TDistance(TInfinityNorm(" + "2" + "))"  //hack for InfinityNorm of degree 2
          case _ => fn.name + "(" + compileTerm(child) + ")"
        }
      // otherwise exception
      case _ => throw new CodeGenerationException("Conversion of term " + t.prettyString + " is not defined")
    }
  }

  private def compileFormula(f: Formula) : String = {
    f match {
      // sub terms are formulas
      case Not(ff) => "logic_neg(" + compileFormula(ff) + ")"
      case And(l, r) => "logic_and(" + compileFormula(l) + ", " + compileFormula(r) + ")"
      case Or(l, r) => "logic_or(" + compileFormula(l) + ", " + compileFormula(r) + ")"
      case Imply(l, r) => "logic_impl(" + compileFormula(l) + ", " + compileFormula(r) + ")"
      case Equiv(l, r) => "logic_equiv(" + compileFormula(l) + ", " + compileFormula(r) + ")"

      // sub terms are arithmetic terms
      case Equal(l, r) => "TEqual(" + compilePolynomialTerm(l) + ", " + compilePolynomialTerm(r) + ")"
      case NotEqual(l, r) => "TNotEqual(" + compilePolynomialTerm(l) + ", " + compilePolynomialTerm(r) + ")"
      case Greater(l,r) => "TLess(" + compilePolynomialTerm(r) + ", " + compilePolynomialTerm(l) + ")"
      case GreaterEqual(l,r) => "TLessEqual(" + compilePolynomialTerm(r) + ", " + compilePolynomialTerm(l) + ")"
      case Less(l,r) => "TLess(" + compilePolynomialTerm(l) + ", " + compilePolynomialTerm(r) + ")"
      case LessEqual(l,r) => "TLessEqual(" + compilePolynomialTerm(l) + ", " + compilePolynomialTerm(r) + ")"
      case True => "true"
      case False => "false"
      case Box(_, _) | Diamond(_, _) => throw new CodeGenerationException("Conversion of Box or Diamond modality is not allowed")
      case _ => throw new CodeGenerationException("Conversion of formula " + f.prettyString + " is not defined")
    }
  }

  private def compilePolynomialTerm(t: Term) : String = {
    val mathTerm = KeYmaeraToMathematica.fromKeYmaera(t)
    val resCoeffList = computeCoeff(mathTerm)
    val resCoeffListLength = resCoeffList.length()
    var coeffVector: Array[Expression] = new Array[Expression](resCoeffListLength)
    val coeffVectorDouble: Array[Double] = new Array[Double](resCoeffListLength)

    var toDouble = true
    for(i <- 0 until resCoeffListLength) {
      coeffVector(i) = MathematicaToKeYmaera.fromMathematica(resCoeffList.args().apply(resCoeffListLength-1-i))
      coeffVector(i) match {
        case Number(n) => coeffVectorDouble(i) = n.underlying().doubleValue()
        case _ => toDouble = false
      }
    }
    var vectorName = ""

    if(coeffVector.length == 0 || coeffVector == null) {
      compileTerm(t)
    } else {
      vectorName = getNewVecName
      val ct : String = hcol.getConstTbl.concat(vectorName + " := var(\"" + vectorName+ "\", TPtr(T_Real(64)));\n")
      hcol.setConstTbl(ct)
      if(toDouble == true) {
        computePolyCoeffDouble(vectorName, coeffVectorDouble)
      } else computePolyCoeff(vectorName, coeffVector)
    }
  }

  private def computeCoeff(t: Expr) : Expr = {
    link.ml.evaluate("CoefficientList["+ t + "," + "KeYmaera`v" +"]") // a hack for variable, should read from commmand line
    link.ml.waitForAnswer()
    link.ml.getExpr
  }

  private def getNewVecName : String = {
    val name = "d_"+vecNameCounter
    vecNameCounter+=1
    name
  }

  private def computePolyCoeffDouble(t: (String, Array[Double])) : String = {
    val vectorName = t._1
    val polyCoeff = t._2
    val degree = polyCoeff.length - 1

    val ceh = hcol.getCoefficientHex.concat("\n__int64 " + vectorName + "[] = {\n" + translateToCoeffsHex(polyCoeff) + "\n};\n")
    hcol.setCoefficientHex(ceh)

    "TEvalPolynomial(" + degree + "," + vectorName + ")"
  }

  private def computePolyCoeff(t: (String, Array[Expression])) : String = {
    val vectorName = t._1
    val polyCoeff = t._2
    val degree = polyCoeff.length - 1

    val ceh = hcol.getCoefficientHex.concat("\n__int64 " + vectorName + "[] = {\n" + translateToCoeffs(polyCoeff) + "\n};\n")
    hcol.setCoefficientHex(ceh)

    "TEvalPolynomial(" + degree + "," + vectorName + ")"
  }

  private def coeffsHex(coeffVecList: List[(String, Array[Double])]) : String = {
    var coeffDec = ""
    for(i <- 0 until coeffVecList.length) {
      val key = coeffVecList(i)._1
      coeffDec += "\n__int64 " + key + "[] = {\n" + translateToCoeffsHex(coeffVecList(i)._2) + "\n};\n"
    }
    coeffDec
  }

  private def translateToCoeffs(coeffVec: Array[Expression]) : String = {
    var coeffsHex = ""
    for(i <- 0 until coeffVec.length) {
      coeffsHex += "  " + coeffVec(i).prettyString
      if(i != coeffVec.length-1) coeffsHex += ",\n"
    }
    coeffsHex
  }

  private def translateToCoeffsHex(coeffVec: Array[Double]) : String = {
    var coeffsHex = ""
    for(i <- 0 until coeffVec.length) {
      coeffsHex += "  " + translateToHex(coeffVec(i))
      if(i != coeffVec.length-1) coeffsHex += ",\n"
    }
    coeffsHex
  }

  private def translateToHex(value: Double) = "0x" + java.lang.Long.toHexString(java.lang.Double.doubleToRawLongBits(value))
}





